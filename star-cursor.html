<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Star Cursor Effect â€” Infinite Click Zoom</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://public.codepenassets.com/css/normalize-5.0.0.min.css"
  />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/quicksettings@3.0.1/quicksettings_black.min.css"
  />
  <style>
    body {
      background: #111;
      touch-action: none;
      margin: 0;
      overflow: hidden;
      user-select: none;
    }
    #view {
      position: fixed;
      inset: 0;
      visibility: hidden;
      display: block;
    }
    #quick-settings {
      position: fixed;
      top: 5px;
      right: 205px;
      z-index: 10;
    }
  </style>
</head>

<body>
  <canvas id="view"></canvas>

  <aside style="display: none">
    <img
      id="star-texture"
      src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/106114/stars-02.png?v=1"
    />
  </aside>

  <div id="quick-settings"></div>

  <script src="https://cdn.jsdelivr.net/quicksettings/3.0.2/quicksettings.min.js"></script>
  <script>
    "use strict";
    console.clear();
    const log = console.log.bind(console);
    const TAU = Math.PI * 2;

    // --------------------------------------------------------------
    // PARTICLE
    // --------------------------------------------------------------
    class Particle {
      constructor(texture, frame) {
        this.texture = texture;
        this.frame = frame;
        this.alive = false;
        this.width = frame.width;
        this.height = frame.height;
        this.originX = frame.width / 2;
        this.originY = frame.height / 2;
      }
      init(x = 0, y = 0) {
        const angle = random(TAU);
        const force = random(2, 6);
        this.x = x;
        this.y = y;
        this.alpha = 1;
        this.alive = true;
        this.theta = angle;
        this.vx = Math.sin(angle) * force;
        this.vy = Math.cos(angle) * force;
        this.rotation = Math.atan2(this.vy, this.vx);
        this.drag = random(0.82, 0.97);
        this.scale = random(0.1, 1);
        this.wander = random(0.5, 1.0);
        this.matrix = { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 };
        return this;
      }
      update() {
        const matrix = this.matrix;
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.drag;
        this.vy *= this.drag;
        this.theta += random(-0.5, 0.5) * this.wander;
        this.vx += Math.sin(this.theta) * 0.1;
        this.vy += Math.cos(this.theta) * 0.1;
        this.rotation = Math.atan2(this.vy, this.vx);
        this.alpha *= 0.98;
        this.scale *= 0.985;
        this.alive = this.scale > 0.06 && this.alpha > 0.06;
        const cos = Math.cos(this.rotation) * this.scale;
        const sin = Math.sin(this.rotation) * this.scale;
        matrix.a = cos;
        matrix.b = sin;
        matrix.c = -sin;
        matrix.d = cos;
        matrix.tx = this.x - (this.originX * matrix.a + this.originY * matrix.c);
        matrix.ty = this.y - (this.originX * matrix.b + this.originY * matrix.d);
        return this;
      }
      draw(context) {
        const m = this.matrix;
        const f = this.frame;
        context.globalAlpha = this.alpha;
        context.setTransform(m.a, m.b, m.c, m.d, m.tx, m.ty);
        context.drawImage(
          this.texture,
          f.x,
          f.y,
          f.width,
          f.height,
          0,
          0,
          this.width,
          this.height
        );
        return this;
      }
    }

    // --------------------------------------------------------------
    // APP
    // --------------------------------------------------------------
    class App {
      constructor(options) {
        this.pool = [];
        this.particles = [];
        this.pointer = { x: -9999, y: -9999 };

        // Offscreen buffer where particles are rendered (world space)
        this.buffer = document.createElement("canvas");
        this.bufferContext = this.buffer.getContext("2d");
        this.supportsFilters = typeof this.bufferContext.filter !== "undefined";

        // Camera/zoom state (screen <-> world)
        this.zoom = 1; // No limits per user request
        this.zoomPoint = { x: 0, y: 0 }; // zoom target (screen-space point)

        // Pointer move: convert to WORLD coords so spawning matches what you see
        this.pointerMove = (event) => {
          event.preventDefault();
          const p = event.targetTouches ? event.targetTouches[0] : event;
          const screenX = p.clientX;
          const screenY = p.clientY;
          const world = this.screenToWorld(screenX, screenY);
          this.pointer.x = world.x;
          this.pointer.y = world.y;
          for (let i = 0; i < random(2, 7); i++) this.spawn(world.x, world.y);
        };

        // Resize
        this.resize = () => {
          this.width = this.buffer.width = this.view.width = window.innerWidth;
          this.height = this.buffer.height = this.view.height = window.innerHeight;
          if (!this.zoomPoint.x && !this.zoomPoint.y) {
            this.zoomPoint.x = this.width / 2;
            this.zoomPoint.y = this.height / 2;
          }
        };

        // Render loop
        this.render = () => {
          const context = this.context;
          const bufferContext = this.bufferContext;

          // Clear view
          context.fillStyle = this.backgroundColor;
          context.fillRect(0, 0, this.width, this.height);

          // Clear buffer
          bufferContext.globalAlpha = 1;
          bufferContext.setTransform(1, 0, 0, 1, 0, 0);
          bufferContext.clearRect(0, 0, this.width, this.height);
          bufferContext.globalCompositeOperation = this.blendMode;

          // Update particles
          for (let i = 0; i < this.particles.length; i++) {
            const particle = this.particles[i];
            if (particle.alive) particle.update();
            else {
              this.pool.push(particle);
              removeItems(this.particles, i, 1);
              i--;
            }
          }

          // Draw particles to buffer (world space)
          for (let particle of this.particles) particle.draw(bufferContext);

          // Draw buffer to screen with camera transform
          const s = this.zoom;
          const px = this.zoomPoint.x;
          const py = this.zoomPoint.y;

          // Apply filters if supported
          if (this.supportsFilters) {
            if (this.useBlurFilter) context.filter = `blur(${this.filterBlur}px)`;
            context.setTransform(s, 0, 0, s, px - s * px, py - s * py);
            context.drawImage(this.buffer, 0, 0);
            if (this.useContrastFilter)
              context.filter = `drop-shadow(4px 4px 4px rgba(0,0,0,1)) contrast(${this.filterContrast}%)`;
            context.setTransform(s, 0, 0, s, px - s * px, py - s * py);
            context.drawImage(this.buffer, 0, 0);
          } else {
            context.setTransform(s, 0, 0, s, px - s * px, py - s * py);
            context.drawImage(this.buffer, 0, 0);
          }

          // Reset
          context.filter = "none";
          context.setTransform(1, 0, 0, 1, 0, 0);

          quickSettings.setValue(
            "Particles",
            `Active = ${this.particles.length}<br>Cached = ${this.pool.length}`
          );

          requestAnimationFrame(this.render);
        };

        Object.assign(this, options);
        this.context = this.view.getContext("2d", { alpha: false });

        // Mouse buttons for infinite zoom (no limits)
        // Left click: zoom in, Right click: zoom out.
        this.onMouseDown = (e) => {
          // Use the click location as zoomPoint (screen space)
          this.zoomPoint.x = e.clientX;
          this.zoomPoint.y = e.clientY;

          // Each click scales by a fixed factor; accumulate without bounds
          const factor = 1.2; // tweakable
          if (e.button === 0) {
            // Left
            this.zoom *= factor;
          } else if (e.button === 2) {
            // Right
            this.zoom /= factor;
          }

          // Keep pointer world coords in sync so spawning stays under cursor
          const world = this.screenToWorld(e.clientX, e.clientY);
          this.pointer.x = world.x;
          this.pointer.y = world.y;
        };

        // Prevent context menu so right-click zoom works
        this.onContextMenu = (e) => e.preventDefault();
      }

      // Convert SCREEN coords to WORLD (inverse of render transform)
      screenToWorld(x, y) {
        const s = this.zoom;
        const px = this.zoomPoint.x;
        const py = this.zoomPoint.y;
        return { x: px + (x - px) / s, y: py + (y - py) / s };
      }

      spawn(x, y) {
        let particle;
        if (this.particles.length > this.maxParticles) particle = this.particles.shift();
        else if (this.pool.length) particle = this.pool.pop();
        else particle = new Particle(this.texture, sample(this.frames));
        particle.init(x, y);
        this.particles.push(particle);
        return this;
      }

      start() {
        this.resize();
        this.render();
        this.view.style.visibility = "visible";

        // Pointer move for trails
        if (window.PointerEvent) window.addEventListener("pointermove", this.pointerMove, { passive: false });
        else {
          window.addEventListener("mousemove", this.pointerMove, { passive: false });
          window.addEventListener("touchmove", this.pointerMove, { passive: false });
        }

        // Zoom handlers
        window.addEventListener("mousedown", this.onMouseDown);
        window.addEventListener("contextmenu", this.onContextMenu);

        // Resize
        window.addEventListener("resize", this.resize);
        requestAnimationFrame(this.render);
        return this;
      }
    }

    // --------------------------------------------------------------
    // Helpers
    // --------------------------------------------------------------
    function createFrames(numFrames, width, height) {
      const frames = [];
      for (let i = 0; i < numFrames; i++) {
        frames.push({ x: width * i, y: 0, width, height });
      }
      return frames;
    }

    function removeItems(array, startIndex, removeCount) {
      const length = array.length;
      if (startIndex >= length || removeCount === 0) return;
      removeCount = startIndex + removeCount > length ? length - startIndex : removeCount;
      const len = length - removeCount;
      for (let i = startIndex; i < len; ++i) array[i] = array[i + removeCount];
      array.length = len;
    }

    function random(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      if (min > max) {
        const tmp = min;
        min = max;
        max = tmp;
      }
      return min + (max - min) * Math.random();
    }

    function sample(array) {
      return array[(Math.random() * array.length) | 0];
    }

    // --------------------------------------------------------------
    // Quick Settings
    // --------------------------------------------------------------
    const app = new App({
      view: document.querySelector("#view"),
      texture: document.querySelector("#star-texture"),
      frames: createFrames(5, 80, 80),
      maxParticles: 2000,
      backgroundColor: "#111111",
      blendMode: "lighter",
      filterBlur: 50,
      filterContrast: 300,
      useBlurFilter: true,
      useContrastFilter: true,
    });

    const blendModes = [
      { label: "Source Over", value: "source-over" },
      { label: "Source In", value: "source-in" },
      { label: "Source Out", value: "source-out" },
      { label: "Source Atop", value: "source-atop" },
      { label: "Destination Over", value: "destination-over" },
      { label: "Destination In", value: "destination-in" },
      { label: "Destination Out", value: "destination-out" },
      { label: "Destination Atop", value: "destination-atop" },
      { label: "Lighter", value: "lighter" },
      { label: "Copy", value: "copy" },
      { label: "Xor", value: "xor" },
      { label: "Multiply", value: "multiply" },
      { label: "Screen", value: "screen" },
      { label: "Overlay", value: "overlay" },
      { label: "Darken", value: "darken" },
      { label: "Lighten", value: "lighten" },
      { label: "Color Dodge", value: "color-dodge" },
      { label: "Color Burn", value: "color-burn" },
      { label: "Hard Light", value: "hard-light" },
      { label: "Soft Light", value: "soft-light" },
      { label: "Difference", value: "difference" },
      { label: "Exclusion", value: "exclusion" },
      { label: "Hue", value: "hue" },
      { label: "Saturation", value: "saturation" },
      { label: "Color", value: "color" },
      { label: "Luminosity", value: "luminosity" },
    ];

    const blendModeNames = blendModes.map((b) => b.label);
    const blendModeIndex = blendModes.findIndex((b) => b.value === app.blendMode);
    const container = document.querySelector("#quick-settings");

    const quickSettings = QuickSettings.create(0, 0, "Settings", container)
      .addHTML("Support", `Supports Filters: ${app.supportsFilters}`)
      .hideTitle("Support")
      .addHTML("Particles", "")
      .addBoolean("Blur Filter", app.useBlurFilter, (v) => {
        app.useBlurFilter = v;
        if (v) quickSettings.showControl("Blur Radius");
        else quickSettings.hideControl("Blur Radius");
      })
      .addRange("Blur Radius", 0, 200, app.filterBlur, 1, (v) => (app.filterBlur = v))
      .addBoolean("Contrast Filter", app.useContrastFilter, (v) => {
        app.useContrastFilter = v;
        if (v) quickSettings.showControl("Contrast");
        else quickSettings.hideControl("Contrast");
      })
      .addRange("Contrast", 0, 400, app.filterContrast, 1, (v) => (app.filterContrast = v))
      .addDropDown("Blend Mode", blendModeNames, (item) => (app.blendMode = blendModes[item.index].value))
      .addColor("Background", app.backgroundColor, (c) => (app.backgroundColor = c))
      .addHTML("Zoom", "")
      .setValue("Blend Mode", blendModeIndex || 0);

    // Keep a live display of zoom
    const updateZoomHUD = () => {
      quickSettings.setValue("Zoom", `Zoom: ${app.zoom.toFixed(4)}x`);
      requestAnimationFrame(updateZoomHUD);
    };
    updateZoomHUD();

    window.addEventListener("load", () => app.start());
    window.focus();
    log("APP", app);
  </script>
</body>
</html>
