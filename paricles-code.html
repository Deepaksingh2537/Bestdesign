<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Particle Network</title>

    <!-- Script Add -->
    <script src="./main.js"></script>

    <style>
        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: linear-gradient(90deg, #0A1F3A, #1C1B2A, #3A0C0C);
            color: #e6e6f0;
            font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        #wrap {
            position: fixed;
            inset: 0;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .hud {
            position: fixed;
            left: 12px;
            bottom: 12px;
            background: #1117;
            backdrop-filter: blur(6px);
            padding: 10px 12px;
            border-radius: 12px;
        }

        .hud b {
            font-weight: 600;
        }

        .hud input[type="range"] {
            width: 160px;
        }

        .hud .row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }

        .hud label {
            width: 84px;
            color: #cfd;
            opacity: .9
        }
    </style>
</head>

<body>
    <div id="wrap"><canvas id="pp"></canvas></div>

    <div class="hud" id="hud">
        <div class="row"><label>Particles</label><input id="count" type="range" min="50" max="2000" step="10"><b
                id="countVal"></b></div>
        <div class="row"><label>Speed</label><input id="speed" type="range" min="0.1" max="2.5" step="0.1"><b
                id="speedVal"></b></div>
        <div class="row"><label>Link dist</label><input id="dist" type="range" min="30" max="220" step="5"><b
                id="distVal"></b></div>
    </div>

    <script type="module">
        // perParticles.js — lightweight, allocation‑free-ish, Canvas2D particle network
        // Features: typed arrays, spatial hashing, DPR scaling, adaptive density.
        // MIT License – use freely.

        class PerParticles {
            constructor(canvas, opts = {}) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: false });
                this.opts = Object.assign({
                    background: '#0f0f12',
                    color: '#cba2ff',         // link + dot color
                    particleRadius: 1.2,
                    maxDistance: 120,
                    speed: 0.6,
                    density: 0.12,            // particles per 10k px^2 (scaled by DPR)
                    pointer: true,
                }, opts);

                // Internal state
                this.w = 0; this.h = 0; this.dpr = Math.max(1, window.devicePixelRatio || 1);
                this.n = 0;           // particle count
                this.data = null;     // Float32Array [x,y,vx,vy]*n
                this.next = null;     // Int32Array next index for buckets
                this.mouseIdx = -1;   // index of pointer pseudo‑particle
                this.running = false; this.lastT = 0;

                // Grid fields (computed per frame, but arrays reused)
                this.cellSize = Math.max(40, this.opts.maxDistance | 0);
                this.gridW = 0; this.gridH = 0; this.head = null; // Int32Array of heads

                // Precompute color components for fast rgba()
                const { r, g, b } = PerParticles.hexToRgb(this.opts.color);
                this.col = { r, g, b };

                // Bindings
                this._onResize = this._onResize.bind(this);
                this._onMove = this._onMove.bind(this);
                this._tick = this._tick.bind(this);

                // Init
                this._onResize();
                window.addEventListener('resize', this._onResize, { passive: true });
                if (this.opts.pointer) {
                    window.addEventListener('mousemove', this._onMove, { passive: true });
                    window.addEventListener('touchmove', e => this._onMove(e.touches[0]), { passive: true });
                }
            }

            static hexToRgb(h) {
                const s = h.replace('#', '');
                const bigint = parseInt(s.length === 3 ? s.split('').map(x => x + x).join('') : s, 16);
                return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
            }

            _alloc(n) {
                this.n = n;
                this.data = new Float32Array(n * 4);
                this.next = new Int32Array(n);
                // grid arrays sized on resize
            }

            _seed() {
                const { data: nv, n } = this;
                const W = this.w, H = this.h, S = this.opts.speed * this.dpr;
                for (let i = 0; i < n; i++) {
                    const p = i * 4;
                    nv[p] = Math.random() * W;
                    nv[p + 1] = Math.random() * H;
                    const a = Math.random() * Math.PI * 2;
                    const s = (0.2 + Math.random() * 0.8) * S; // varied speeds
                    nv[p + 2] = Math.cos(a) * s;
                    nv[p + 3] = Math.sin(a) * s;
                }
                // Reserve last slot for mouse pointer particle if enabled
                if (this.opts.pointer) {
                    this.mouseIdx = n - 1;
                    const p = this.mouseIdx * 4;
                    nv[p] = this.w * 0.5; nv[p + 1] = this.h * 0.5; nv[p + 2] = 0; nv[p + 3] = 0;
                }
            }

            _onResize() {
                const cssW = this.canvas.clientWidth || window.innerWidth;
                const cssH = this.canvas.clientHeight || window.innerHeight;
                this.dpr = Math.max(1, window.devicePixelRatio || 1);
                this.w = Math.floor(cssW * this.dpr);
                this.h = Math.floor(cssH * this.dpr);
                this.canvas.width = this.w;
                this.canvas.height = this.h;

                // Estimate particle count by area (dens per 10k px^2)
                const base = Math.round((this.w * this.h) / (10000) * this.opts.density);
                const n = Math.max(50, base) + (this.opts.pointer ? 1 : 0);

                this._alloc(n);

                // grid size depends on maxDistance
                this.cellSize = Math.max(32, this.opts.maxDistance | 0);
                this.gridW = Math.ceil(this.w / this.cellSize);
                this.gridH = Math.ceil(this.h / this.cellSize);
                this.head = new Int32Array(this.gridW * this.gridH);

                // background clear
                this.ctx.fillStyle = this.opts.background;
                this.ctx.fillRect(0, 0, this.w, this.h);

                this._seed();
            }

            _onMove(e) {
                if (this.mouseIdx < 0) return;
                const rect = this.canvas.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * this.dpr;
                const my = (e.clientY - rect.top) * this.dpr;
                const p = this.mouseIdx * 4;
                this.data[p] = mx; this.data[p + 1] = my; // no velocity
            }

            start() { if (!this.running) { this.running = true; this.lastT = performance.now(); requestAnimationFrame(this._tick); } }
            stop() { this.running = false; }

            setOptions(newOpts) {
                Object.assign(this.opts, newOpts);
                const { r, g, b } = PerParticles.hexToRgb(this.opts.color); this.col = { r, g, b };
                this._onResize();
            }

            _bucket(x, y) {
                const cx = Math.max(0, Math.min(this.gridW - 1, (x / this.cellSize) | 0));
                const cy = Math.max(0, Math.min(this.gridH - 1, (y / this.cellSize) | 0));
                return cy * this.gridW + cx;
            }

            _buildGrid() {
                this.head.fill(-1);
                const d = this.data; const n = this.n;
                for (let i = 0; i < n; i++) {
                    const p = i * 4; const h = this._bucket(d[p], d[p + 1]);
                    this.next[i] = this.head[h]; this.head[h] = i;
                }
            }

            _integrate(dt) {
                const d = this.data; const n = this.n; const W = this.w, H = this.h;
                for (let i = 0; i < n; i++) {
                    if (i === this.mouseIdx) continue; // mouse stays where placed
                    const p = i * 4; let x = d[p], y = d[p + 1];
                    x += d[p + 2] * dt; y += d[p + 3] * dt;
                    // wrap around edges (cheaper than bounce)
                    if (x < 0) x += W; else if (x >= W) x -= W;
                    if (y < 0) y += H; else if (y >= H) y -= H;
                    d[p] = x; d[p + 1] = y;
                }
            }

            _render(dt) {
                const ctx = this.ctx; const d = this.data; const n = this.n;
                const maxD = this.opts.maxDistance * this.dpr; const maxD2 = maxD * maxD;
                const r = this.opts.particleRadius * this.dpr;

                // soft clear
                ctx.fillStyle = this.opts.background;
                ctx.globalAlpha = 1.0;
                ctx.fillRect(0, 0, this.w, this.h);

                // Draw links using spatial hashing — check neighbors in 9 cells only
                const { r: cr, g: cg, b: cb } = this.col;
                ctx.lineWidth = Math.max(0.5, (0.8 * this.dpr));

                const w = this.gridW, h = this.gridH, head = this.head, next = this.next;
                for (let gy = 0; gy < h; gy++) {
                    for (let gx = 0; gx < w; gx++) {
                        const gi = gy * w + gx;
                        for (let i = head[gi]; i !== -1; i = next[i]) {
                            const ip = i * 4; const ix = d[ip], iy = d[ip + 1];
                            // neighbor cells
                            for (let ny = -1; ny <= 1; ny++) {
                                const cy = gy + ny; if (cy < 0 || cy >= h) continue;
                                for (let nx = -1; nx <= 1; nx++) {
                                    const cx = gx + nx; if (cx < 0 || cx >= w) continue;
                                    for (let j = head[cy * w + cx]; j !== -1; j = next[j]) {
                                        if (j <= i) continue; // avoid duplicates
                                        const jp = j * 4; const dx = d[jp] - ix, dy = d[jp + 1] - iy; const dist2 = dx * dx + dy * dy;
                                        if (dist2 <= maxD2) {
                                            const a = 1 - Math.sqrt(dist2) / maxD; // alpha
                                            ctx.strokeStyle = `rgba(${cr},${cg},${cb},${(0.35 * a).toFixed(3)})`;
                                            ctx.beginPath(); ctx.moveTo(ix, iy); ctx.lineTo(d[jp], d[jp + 1]); ctx.stroke();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Draw particles
                ctx.fillStyle = `rgba(${cr},${cg},${cb},0.95)`;
                ctx.beginPath();
                for (let i = 0; i < n; i++) {
                    const p = i * 4; const x = d[p], y = d[p + 1];
                    ctx.moveTo(x + r, y); ctx.arc(x, y, r, 0, Math.PI * 2);
                }
                ctx.fill();
            }

            _tick(t) {
                if (!this.running) return;
                const dt = Math.min(64, t - this.lastT) / 16.6667; // normalize to ~60fps units
                this.lastT = t;
                this._integrate(dt);
                this._buildGrid();
                this._render(dt);
                requestAnimationFrame(this._tick);
            }
        }

        // --- Boot the demo ---
        const canvas = document.getElementById('pp');
        const pp = new PerParticles(canvas, {
            color: '#cba2ff',
            maxDistance: 140,
            particleRadius: 1.2,
            speed: 0.6,
            // density is particles per 10k px^2 (adjusted on resize)
            density: 0.11,
        });
        pp.start();

        // HUD controls (for easy tweaking)
        const $ = sel => document.querySelector(sel);
        const fmt = v => (typeof v === 'number' ? v.toFixed(0) : v);
        const bind = (id, get, set) => {
            const el = $(id), out = $(id + "Val");
            el.value = get(); out.textContent = fmt(get());
            el.addEventListener('input', () => { set(parseFloat(el.value)); out.textContent = fmt(get()); });
        };
        bind('#count', () => pp.n - (pp.opts.pointer ? 1 : 0), v => {
            // re‑seed with new count
            const pointer = pp.opts.pointer ? 1 : 0;
            pp._alloc(Math.max(10, v) + pointer);
            pp._seed();
        });
        bind('#speed', () => pp.opts.speed, v => { pp.opts.speed = v; /* velocities updated next seed */ });
        bind('#dist', () => pp.opts.maxDistance, v => { pp.opts.maxDistance = v; pp.cellSize = Math.max(32, v | 0); pp._onResize(); });

        // expose globally for quick fiddling
        window.perParticles = pp;
    </script>
</body>

</html>